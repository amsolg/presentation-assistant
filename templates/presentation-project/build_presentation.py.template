#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script d'orchestration automatique - {PRESENTATION_SUBJECT} pour {AUDIENCE_NAME}
G√©n√©r√© automatiquement par le Presentation Assistant le {CREATION_DATE}

Ce script utilise l'ARCHITECTURE JSON 2025 avec presentation_builder
pour construire une pr√©sentation adapt√©e sp√©cifiquement √† l'audience {AUDIENCE_NAME}.

Configuration audience:
- Niveau d'expertise: {EXPERTISE_LEVEL}
- Style Sam: {SAM_STYLE}
- Dur√©e cible: {TARGET_DURATION} minutes
- Slides configur√©es: {SCRIPTS_COUNT}

ARCHITECTURE JSON 2025:
- Un fichier JSON de sch√©ma de pr√©sentation d√©finit la structure compl√®te
- Chaque slide sp√©cifie sa position, le script √† appeler et son payload JSON
- Les fichiers payload contiennent les donn√©es sp√©cifiques √† chaque slide
- L'orchestrateur presentation_builder.py coordonne l'ensemble automatiquement
- Pas besoin d'appels manuels aux scripts individuels
"""

import os
import sys
import subprocess
import json
from datetime import datetime
from pathlib import Path

class PresentationOrchestrator:
    """Orchestrateur pour la construction automatique de pr√©sentation avec architecture JSON 2025"""

    def __init__(self):
        self.project_root = Path(__file__).parent.parent.parent.parent
        self.presentation_builder_path = self.project_root / "presentation_builder"
        self.output_dir = Path(__file__).parent / "output"
        self.output_dir.mkdir(exist_ok=True)

        # Configuration sp√©cifique √† l'audience
        self.audience_config = {
            "audience": "{AUDIENCE_NAME}",
            "expertise_level": "{EXPERTISE_LEVEL}",
            "duration_target": "{TARGET_DURATION} minutes",
            "sam_style": "{SAM_STYLE}",
            "technical_depth": "{TECHNICAL_DEPTH}",
            "communication_style": "{COMMUNICATION_STYLE}"
        }

        # Informations du projet
        self.project_info = {
            "subject": "{PRESENTATION_SUBJECT}",
            "creation_date": "{CREATION_DATE}",
            "target_audience": "{AUDIENCE_NAME}",
            "estimated_slides": {ESTIMATED_SLIDES},
            "complexity_level": "{COMPLEXITY_LEVEL}"
        }

        # Configuration de pr√©sentation JSON 2025
        self.presentation_schema_path = Path(__file__).parent / "presentation_schema.json"

        # Exemple de sch√©ma de pr√©sentation pour l'architecture JSON 2025
        self.presentation_schema_template = {
            "presentation_name": "{PRESENTATION_TITLE}",
            "subject": "{PRESENTATION_SUBJECT}",
            "audience": "{AUDIENCE_NAME}",
            "title_slide": {
                "title": "{PRESENTATION_TITLE}",
                "subtitle": "{PRESENTATION_SUBTITLE}",
                "metadata": "{CREATION_DATE} ‚Äì {AUDIENCE_NAME}"
            },
            "slides": [],  # Configuration des slides avec position, script_name et payload_path
            "build_options": {
                "auto_widen_text": True,
                "generate_reports": True,
                "preserve_styles": True
            }
        }

    def log_step(self, step, message):
        """Log des √©tapes de construction"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] √âTAPE {step}: {message}")

    def build_presentation_json(self, schema_path=None):
        """Construit la pr√©sentation en utilisant l'architecture JSON 2025"""
        if schema_path is None:
            schema_path = self.presentation_schema_path

        self.log_step("JSON", f"Construction pr√©sentation via sch√©ma JSON: {schema_path}")

        # Importer le PresentationBuilder
        sys.path.insert(0, str(self.presentation_builder_path))
        from presentation_builder import PresentationBuilder

        try:
            # Charger le sch√©ma de pr√©sentation
            with open(schema_path, 'r', encoding='utf-8') as f:
                presentation_config = json.load(f)

            self.log_step("LOAD", f"Sch√©ma charg√©: {presentation_config.get('presentation_name', 'Sans nom')}")

            # Cr√©er l'orchestrateur
            builder = PresentationBuilder()

            # G√©n√©rer le nom de fichier de sortie
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{timestamp}_{presentation_config.get('subject', 'presentation')}_{presentation_config.get('audience', 'audience')}.pptx"
            output_path = self.output_dir / filename

            self.log_step("BUILD", f"Construction vers: {output_path}")

            # Construire la pr√©sentation
            result = builder.build_presentation(presentation_config, str(output_path))

            if result:
                self.log_step("SUCCESS", f"Pr√©sentation cr√©√©e avec succ√®s: {filename}")
                return str(output_path)
            else:
                self.log_step("ERROR", "√âchec de la construction de la pr√©sentation")
                return None

        except Exception as e:
            self.log_step("ERROR", f"Erreur construction JSON: {e}")
            return None

    def validate_environment(self):
        """Valide l'environnement pour l'architecture JSON 2025"""
        self.log_step("VALIDATE", "Validation de l'environnement JSON 2025")

        # V√©rifier template Premier Tech
        template_path = self.project_root / "templates" / "Template_PT.pptx"
        if not template_path.exists():
            self.log_step("ERROR", f"Template Premier Tech non trouv√©: {template_path}")
            return False

        # V√©rifier l'orchestrateur principal
        main_builder = self.presentation_builder_path / "presentation_builder.py"
        if not main_builder.exists():
            self.log_step("ERROR", f"Orchestrateur principal non trouv√©: {main_builder}")
            return False

        # Scripts de la nouvelle architecture (sans num√©rotation)
        required_scripts = [
            "navigation_builder.py",
            "section_header_builder.py",
            "simple_message_builder.py",
            "statistics_builder.py",
            "content_boxes_builder.py",
            "detailed_explanation_builder.py",
            "testimonial_builder.py",
            "charts_builder.py"
        ]

        # Valider les scripts disponibles
        available_scripts = []
        for script in required_scripts:
            script_path = self.presentation_builder_path / script
            if script_path.exists():
                available_scripts.append(script[:-3])  # Enlever .py
                self.log_step("OK", f"Script disponible: {script}")
            else:
                self.log_step("WARNING", f"Script non disponible: {script}")

        # V√©rifier le sch√©ma de pr√©sentation
        if not self.presentation_schema_path.exists():
            self.log_step("WARNING", f"Sch√©ma de pr√©sentation non trouv√©: {self.presentation_schema_path}")
            self.log_step("INFO", "Le sch√©ma sera g√©n√©r√© automatiquement")

        self.log_step("VALIDATE", f"{len(available_scripts)} scripts disponibles sur {len(required_scripts)}")
        return True  # Valide m√™me si certains scripts manquent

    def run(self):
        """Ex√©cute la construction compl√®te de la pr√©sentation"""
        self.log_step("START", "D√©but de la construction automatique")
        self.log_step("AUDIENCE", f"Cible: {self.audience_config['audience']}")
        self.log_step("CONFIG", f"Style: {self.audience_config['sam_style']}")

        # Validation de l'environnement
        if not self.validate_environment():
            self.log_step("ABORT", "Environnement invalide - Construction annul√©e")
            return False

        # Construction via JSON 2025
        result_path = self.build_presentation_json()

        if result_path:
            self.log_step("COMPLETE", f"Pr√©sentation cr√©√©e: {result_path}")
            return result_path
        else:
            self.log_step("FAILED", "√âchec de la construction")
            return False


def main():
    """Point d'entr√©e principal"""
    print("="*80)
    print("PRESENTATION ASSISTANT - ARCHITECTURE JSON 2025")
    print("Script d'orchestration automatique")
    print(f"Sujet: {'{PRESENTATION_SUBJECT}'}")
    print(f"Audience: {'{AUDIENCE_NAME}'}")
    print(f"Expertise: {'{EXPERTISE_LEVEL}'}")
    print("="*80)

    try:
        orchestrator = PresentationOrchestrator()
        result = orchestrator.run()

        if result:
            print(f"\n‚úÖ SUCCESS: Pr√©sentation cr√©√©e avec succ√®s")
            print(f"üìÑ Fichier: {result}")
            return 0
        else:
            print(f"\n‚ùå FAILED: √âchec de la cr√©ation")
            return 1

    except KeyboardInterrupt:
        print(f"\n‚ö†Ô∏è  Interruption utilisateur")
        return 1
    except Exception as e:
        print(f"\nüí• ERREUR: {e}")
        return 1


if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)